const char *SOURCE_LOAD_FRAGMENT =

"uniform float u_Time;\n"
"uniform vec2 u_Resolution;\n"

"\n"

"\n"

"#define time u_Time*2.6\n"
"#define pi 3.14159265\n"

"#define NUM 20.\n"
"#define PALETTE vec3(.0, 1.4, 2.)+1.5\n"

"#define COLORED\n"
"#define MIRROR\n"
"\n"
"#define ROT_OFST\n"
"#define TRIANGLE_NOISE\n"

"\n"

"float aspect = u_Resolution.x/u_Resolution.y;\n"
"float w = 50./sqrt(u_Resolution.x*aspect+u_Resolution.y);\n"

"mat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,-s,s,c);}\n"
"float tri(in float x){return abs(fract(x)-.5);}\n"
"vec2 tri2(in vec2 p){return vec2(tri(p.x+tri(p.y*2.)),tri(p.y+tri(p.x*2.)));}\n"
"mat2 m2 = mat2( 0.970,  0.242, -0.242,  0.970 );\n"

"\n"
"float triangleNoise(in vec2 p)\n"
"{\n"
"    float z=1.5;\n"
"    float z2=1.5;\n"
"	float rz = 0.;\n"
"    vec2 bp = p;\n"
"	for (float i=0.; i<=3.; i++ )\n"
"	{\n"
"        vec2 dg = tri2(bp*2.)*.8;\n"
"        dg *= mm2(time*.3);\n"
"        p += dg/z2;\n"

"        bp *= 1.6;\n"
"        z2 *= .6;\n"
"		z *= 1.8;\n"
"		p *= 1.2;\n"
"        p*= m2;\n"
"        \n"
"        rz+= (tri(p.x+tri(p.y)))/z;\n"
"	}\n"
"	return rz;\n"
"}\n"

"void main() \n"
"{\n"
"    vec2 p = gl_FragCoord.xy / u_Resolution.xy*2.-1.;\n"
"	p.x *= aspect;\n"
"    p*= 1.05;\n"
"    vec2 bp = p;\n"
"    \n"
"    #ifdef ROTATE\n"
"    p *= mm2(time*.25);\n"
"    #endif\n"
"    \n"
"    float lp = length(p);\n"
"    float id = floor(lp*NUM+.5)/NUM;\n"
"    \n"
"    #ifdef ROT_OFST\n"
"    p *= mm2(id*11.);\n"
"    #endif\n"
"    \n"
"    #ifdef MIRROR\n"
"    p.y = abs(p.y); \n"
"    #endif\n"
"    \n"
"    \n"
"    vec2 plr = vec2(lp, atan(p.y, p.x));\n"
"    \n"
"    \n"
"    float rz = 1.-pow(abs(sin(plr.x*pi*NUM))*1.25/pow(w,0.25),2.5);\n"
"    \n"
"    \n"
"    float enp = plr.y+sin((time+id*5.5))*1.52-1.5;\n"
"    rz *= smoothstep(0., 0.05, enp);\n"
"    \n"
"    \n"
"    rz *= smoothstep(0.,.022*w/plr.x, enp)*step(id,1.);\n"
"    #ifndef MIRROR\n"
"    rz *= smoothstep(-0.01,.02*w/plr.x,pi-plr.y);\n"
"    #endif\n"
"    \n"
"    #ifdef TRIANGLE_NOISE\n"
"    rz *= (triangleNoise(p/(w*w))*0.9+0.4);\n"
"    vec3 col = (sin(PALETTE+id*5.+time)*0.5+0.5)*rz;\n"
"    col += smoothstep(.4,1.,rz)*0.15;\n"
"    col *= smoothstep(.2,1.,rz)+1.;\n"
"    \n"
"    #else\n"
"    vec3 col = (sin(PALETTE+id*5.+time)*0.5+0.5)*rz;\n"
"    col *= smoothstep(.8,1.15,rz)*.7+.8;\n"
"    #endif\n"
"    \n"
"    #ifndef COLORED\n"
"    col = vec3(dot(col,vec3(.7)));\n"
"    #endif\n"
"    \n"
"    #ifdef SHOW_TRIANGLE_NOISE_ONLY\n"
"    col = vec3(triangleNoise(bp));\n"
"    #endif\n"
"    \n"
"	gl_FragColor = vec4(col,1.0);\n"
"    \n"
"}\n";